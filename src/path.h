/**
 * path.h
 *
 * Copyright (c) 2021 Yuriy Lisovskiy
 *
 * Platform-dependent includes of path utilities.
 */

#pragma once

// C++ libraries.
#include <string>
#include <memory>
#include <filesystem>

// Base libraries.
#include "./sys.h"
#include "./file.h"
#include "./abc/base.h"

#if defined(__linux__) || defined(__mac__)
#include "./_path/posix.h"
#endif // __linux__ || __mac__

#ifdef __windows__
#include "./_path/nt.h"
#endif // __windows__


__PATH_BEGIN__

// TESTME: prefix_and_suffix
// 'prefix_and_suffix' splits pattern by the last wildcard "*", if applicable,
// returning prefix as the part before "*" and suffix as the part after "*".
extern std::pair<std::string, std::string> prefix_and_suffix(const std::string& pattern);

// TESTME: reseed
extern int reseed();

// TESTME: next_random
extern std::string next_random();

// TESTME: temp_file
// 'temp_file' creates a new temporary file in the directory dir,
// opens the file for reading and writing, and returns the resulting
// 'std::unique_ptr<File>'.
// The filename is generated by taking pattern and adding a random
// string to the end. If pattern includes a "*", the random string
// replaces the last "*".
// If dir is the empty string, 'temp_file' uses the default directory
// for temporary files (see 'std::filesystem::temp_directory_path()').
// Multiple programs calling 'temp_file' simultaneously
// will not choose the same file. The caller can use 'file.path()'
// to find the pathname of the file. It is the caller's responsibility
// to remove the file when no longer needed.
extern std::unique_ptr<File> temp_file(std::string dir, const std::string& pattern, bool is_binary);

// `p`: path to access.
//
// Returns file size in bytes.
inline size_t get_size(const std::string& p)
{
	return file_stat(p).st_size;
}

// TESTME: _split_text
// Split a path in root and extension.
// The extension is everything starting at the last dot in the last
// pathname component; the root is everything before that.
// It is always true that root + ext == p.
//
// Generic implementation of splitext, to be parametrized with
// the separators.
extern void _split_text(
	const std::string& full_path, char sep, char alt_separator,
	char ext_separator, std::string& root_out, std::string& ext_out
);

// TESTME: split_text
// Split a path in root and extension.
// The extension is everything starting at the last dot in the last
// pathname component; the root is everything before that.
// It is always true that `root + ext == p`.
inline void split_text(const std::string& full_path, std::string& root_out, std::string& ext_out)
{
	_split_text(full_path, path::path_sep, path::alt_sep, path::ext_sep, root_out, ext_out);
}

// TESTME: Path
// TODO: docs for 'Path'
class Path final : public abc::IStringSerializable
{
public:
	inline Path() : _exists(false)
	{
	}

	inline Path(std::string p) : _string_path(std::move(p))
	{
		this->_exists = std::filesystem::exists(this->_string_path);
	}

	[[nodiscard]]
	inline std::string to_string() const override
	{
		return this->_string_path;
	}

	[[nodiscard]]
	inline std::string to_std_path() const
	{
		if (!this->exists())
		{
			throw PathError("Path '" + this->_string_path + "' does not exist", _ERROR_DETAILS_);
		}

		return std::filesystem::path(this->_string_path);
	}

	inline Path operator/ (const Path& other) const
	{
		return {join(this->to_string(), other.to_string())};
	}

	inline Path operator/ (const std::string& other) const
	{
		return {join(this->to_string(), other)};
	}

	inline Path operator/ (const char* other) const
	{
		return {join(this->to_string(), other)};
	}

	[[nodiscard]]
	inline bool is_absolute() const
	{
		return _is_absolute(this->_string_path);
	}

	[[nodiscard]]
	inline std::string dirname() const
	{
		return _dirname(this->_string_path);
	}

	[[nodiscard]]
	inline std::string basename() const
	{
		return _basename(this->_string_path);
	}

	[[nodiscard]]
	inline bool exists() const
	{
		return this->_exists;
	}

	[[nodiscard]]
	inline bool empty() const
	{
		return this->_string_path.empty();
	}

private:
	bool _exists;
	std::string _string_path;
};

__PATH_END__
